DONE

	No, there is totally a lot more work to do...

	The proxy can't work (yet), because it doesn't know which client to return the packet to.

	To fix this, there needs to be an array of worker sockets in the proxy, and a mapping from client address to slot (n slots per-thread, eg. 4000)

	Then the proxy can receive the packet on the socket corresponding to the slot, 

	Switch proxy to blocking sockets and don't pin cores or set high priority.

	Leave server as is, high priority thread and pinned cores... it's simpler, and we can always test throughput on server vs. proxy by pointing the client directly at the server IP sans proxy.

	Actually create the slot threads, owned by each thread. This way there is no contention for slots between threads.

	Port number should be 50000 + (thread_number*num_slots_per_thread) + slot

	This gives us room for around ~10k slots maximum, which is perfectly fine.

	Actually create the slot sockets.

	Make sure the slot sockets get closed on thread shutdown, and make sure the slots actually shut down.

	Test everything is creating and shutting down cleanly.

	Make slot data get allocated 1mb apart dynamically.

	If slot socket receives packet from server, check if allocated and if so, forward packet to client address.

	When packet is received on the proxy socket:

	1. It must be from a client... check.

	2. Lookup in a hash map to see if the client already exists. If so, use the socket for that slot to forward the packet to the server.

	3. If not already existing, add entry if possible (if not, drop packet), then forward packet to server.

	This should be enough to get the proxy working.

	Have the proxy part coded (in theory). 

	Test it in google cloud with a single client to verify logic w. logs, and especially, to verify that packets from a single client stays on one thread.

	Works fine.

	Now move the printfs to debug_print #define... and nop.

	And then scale it up to 1000 clients... :)

TODO

	Found a bug. Was not setting the last packet received time, so slots were getting continually stomped.

