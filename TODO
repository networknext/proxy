DONE

	Renamed hash_table to session_table and implemented double buffer swap for timeouts without O(n).

	Server was creating the slot sockets, which messed things up. only proxy creates them now.

	Implement test for session table that exercises swap.

	Implement swap every 30 seconds for the session table in the proxy.

	Session table get needs to move the session to current on get from previous.

	Verify a client remains connected across two swaps now.

	Force the next client to use a specific port, and then verify that it can reconnect and get "new client", 60+ seconds after it first connects to the proxy.

	Verified, but had to work around blocking socket recv timeout not working on macos.

	Don't set SO_REUSEPORT or SO_REUSEADDR on sockets unless needed.

	Add packet filter code to proxy.

	Implement code to check non-zero byte packets against the stateless packet filter.

	If the packet fails the stateless packet filter, drop it.

	Check for valid network next packet types and print them out.

	No need to stop the server creating a socket. The next server needs the socket for comms with the backend.

	Proxy sockets no longer need to take backend packets.

	Adding an extra next socket per-next thread is a bad idea. Use the network next socket native. It's already setup to work with multiple threads (internal receive thread, main thread for sends etc.)

	Network Next server needs a callback to optionally process a packet, adjust the "from", and change start and size.

	This callback will be called when packets are received in the receive thread, and will make it possible for me to implement the proxy address prefix in a generic way without hardcoding "proxy mode" into the next server.

	Sketched out the callback roughly.

	Update next_server_internal_process_network_next_packet to work with begin/end for backend packets.

	Update read backend packet function to use begin/end.

	Now update next_read_packet to use begin/end.

	Update all unit tests to the new way of reading packets.

TODO

	Update all code in the client and server to use the new way of reading packets.

	--------------

	Forward network next packets to the next thread, prefixed by the packet type, client address ipv4 and port number (7 bytes total).

	--------------

	Implement callback to send packets to an address on behalf of the server.

	Use this callback to implement next server sending non-backend packets via proxy sockets w. the hash of the client address being used to index into the proxy socket array.

	--------------

	Implement some sort of short circuit callback when a direct or network next packet is received from the client.

	This is important so the packet doesn't get an additional 16.67ms of latency added with frame quantization in the next thread.

	--------------

	Get the server actually initing with the server backend 5.

	--------------

	Verify that network next acceleration works through the proxy.

	--------------

	Load test again in google, to make sure nothing has broken.

	--------------

	Setup a relay in GCore ashburn datacenter (10G).

	Setup a client, server and proxy in GCore (10G).

	Load test in GCore.

	--------------

	SDK 5 needs a passthrough only direct mode. Otherwise, we will need the multiple network next proxy server thread functionality for PoC.

	--------------

	Work is done :)

	--------------
